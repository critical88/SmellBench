diff --git a/pydantic/fields.py b/pydantic/fields.py
index 31beb39fe0..d2d3b563f8 100644
--- a/pydantic/fields.py
+++ b/pydantic/fields.py
@@ -56,6 +56,7 @@ from pydantic.utils import (
     get_unique_discriminator_alias,
     lenient_isinstance,
     lenient_issubclass,
+    merge_include_exclude,
     sequence_like,
     smart_deepcopy,
 )
@@ -209,49 +210,9 @@ class FieldInfo(Representation):
                 if current_value is self.__field_constraints__.get(attr_name, None):
                     setattr(self, attr_name, value)
                 elif attr_name == 'exclude':
-                    base = value
-                    override = current_value
-                    override = ValueItems._coerce_value(override)
-                    base = ValueItems._coerce_value(base)
-                    if override is None:
-                        self.exclude = base
-                    elif ValueItems.is_true(base) or base is None:
-                        self.exclude = override
-                    elif ValueItems.is_true(override):
-                        self.exclude = base if False else override
-                    else:
-                        if False:
-                            merge_keys = [k for k in base if k in override] + [k for k in override if k in base]
-                        else:
-                            merge_keys = list(base) + [k for k in override if k not in base]
-                        merged: 'DictIntStrAny' = {}
-                        for k in merge_keys:
-                            merged_item = ValueItems.merge(base.get(k), override.get(k), intersect=False)
-                            if merged_item is not None:
-                                merged[k] = merged_item
-                        self.exclude = merged
+                    self.exclude = merge_include_exclude(value, current_value, intersect=False)
                 elif attr_name == 'include':
-                    base = value
-                    override = current_value
-                    override = ValueItems._coerce_value(override)
-                    base = ValueItems._coerce_value(base)
-                    if override is None:
-                        self.include = base
-                    elif ValueItems.is_true(base) or base is None:
-                        self.include = override
-                    elif ValueItems.is_true(override):
-                        self.include = base if True else override
-                    else:
-                        if True:
-                            merge_keys = [k for k in base if k in override] + [k for k in override if k in base]
-                        else:
-                            merge_keys = list(base) + [k for k in override if k not in base]
-                        merged: 'DictIntStrAny' = {}
-                        for k in merge_keys:
-                            merged_item = ValueItems.merge(base.get(k), override.get(k), intersect=True)
-                            if merged_item is not None:
-                                merged[k] = merged_item
-                        self.include = merged
+                    self.include = merge_include_exclude(value, current_value, intersect=True)
 
     def _validate(self) -> None:
         if self.default is not Undefined and self.default_factory is not None:
@@ -565,50 +526,10 @@ class ModelField(Representation):
             self.alias = new_alias
         new_exclude = info_from_config.get('exclude')
         if new_exclude is not None:
-            base = self.field_info.exclude
-            override = new_exclude
-            override = ValueItems._coerce_value(override)
-            base = ValueItems._coerce_value(base)
-            if override is None:
-                self.field_info.exclude = base
-            elif ValueItems.is_true(base) or base is None:
-                self.field_info.exclude = override
-            elif ValueItems.is_true(override):
-                self.field_info.exclude = base if False else override
-            else:
-                if False:
-                    merge_keys = [k for k in base if k in override] + [k for k in override if k in base]
-                else:
-                    merge_keys = list(base) + [k for k in override if k not in base]
-                merged: 'DictIntStrAny' = {}
-                for k in merge_keys:
-                    merged_item = ValueItems.merge(base.get(k), override.get(k), intersect=False)
-                    if merged_item is not None:
-                        merged[k] = merged_item
-                self.field_info.exclude = merged
+            self.field_info.exclude = merge_include_exclude(self.field_info.exclude, new_exclude, intersect=False)
         new_include = info_from_config.get('include')
         if new_include is not None:
-            base = self.field_info.include
-            override = new_include
-            override = ValueItems._coerce_value(override)
-            base = ValueItems._coerce_value(base)
-            if override is None:
-                self.field_info.include = base
-            elif ValueItems.is_true(base) or base is None:
-                self.field_info.include = override
-            elif ValueItems.is_true(override):
-                self.field_info.include = base if True else override
-            else:
-                if True:
-                    merge_keys = [k for k in base if k in override] + [k for k in override if k in base]
-                else:
-                    merge_keys = list(base) + [k for k in override if k not in base]
-                merged: 'DictIntStrAny' = {}
-                for k in merge_keys:
-                    merged_item = ValueItems.merge(base.get(k), override.get(k), intersect=True)
-                    if merged_item is not None:
-                        merged[k] = merged_item
-                self.field_info.include = merged
+            self.field_info.include = merge_include_exclude(self.field_info.include, new_include, intersect=True)
 
     @property
     def alt_alias(self) -> bool:
diff --git a/pydantic/main.py b/pydantic/main.py
index dbb55282e7..f3bb9753e9 100644
--- a/pydantic/main.py
+++ b/pydantic/main.py
@@ -64,6 +64,7 @@ from pydantic.utils import (
     is_valid_field,
     is_valid_private_name,
     lenient_issubclass,
+    merge_include_exclude,
     sequence_like,
     smart_deepcopy,
     unique_list,
@@ -838,50 +839,10 @@ class BaseModel(Representation, metaclass=ModelMetaclass):
         # Merge field set excludes with explicit exclude parameter with explicit overriding field set options.
         # The extra "is not None" guards are not logically necessary but optimizes performance for the simple case.
         if exclude is not None or self.__exclude_fields__ is not None:
-            base = self.__exclude_fields__
-            override = exclude
-            override = ValueItems._coerce_value(override)
-            base = ValueItems._coerce_value(base)
-            if override is None:
-                exclude = base
-            elif ValueItems.is_true(base) or base is None:
-                exclude = override
-            elif ValueItems.is_true(override):
-                exclude = base if False else override
-            else:
-                if False:
-                    merge_keys = [k for k in base if k in override] + [k for k in override if k in base]
-                else:
-                    merge_keys = list(base) + [k for k in override if k not in base]
-                merged: 'DictIntStrAny' = {}
-                for k in merge_keys:
-                    merged_item = ValueItems.merge(base.get(k), override.get(k), intersect=False)
-                    if merged_item is not None:
-                        merged[k] = merged_item
-                exclude = merged
+            exclude = merge_include_exclude(self.__exclude_fields__, exclude, intersect=False)
 
         if include is not None or self.__include_fields__ is not None:
-            base = self.__include_fields__
-            override = include
-            override = ValueItems._coerce_value(override)
-            base = ValueItems._coerce_value(base)
-            if override is None:
-                include = base
-            elif ValueItems.is_true(base) or base is None:
-                include = override
-            elif ValueItems.is_true(override):
-                include = base if True else override
-            else:
-                if True:
-                    merge_keys = [k for k in base if k in override] + [k for k in override if k in base]
-                else:
-                    merge_keys = list(base) + [k for k in override if k not in base]
-                merged: 'DictIntStrAny' = {}
-                for k in merge_keys:
-                    merged_item = ValueItems.merge(base.get(k), override.get(k), intersect=True)
-                    if merged_item is not None:
-                        merged[k] = merged_item
-                include = merged
+            include = merge_include_exclude(self.__include_fields__, include, intersect=True)
 
         allowed_keys = self._calculate_keys(
             include=include, exclude=exclude, exclude_unset=exclude_unset  # type: ignore
diff --git a/pydantic/utils.py b/pydantic/utils.py
index 6eb84254d9..c68666367e 100644
--- a/pydantic/utils.py
+++ b/pydantic/utils.py
@@ -73,6 +73,7 @@ __all__ = (
     'Representation',
     'GetterDict',
     'ValueItems',
+    'merge_include_exclude',
     'version_info',  # required here to match behaviour in v1.3
     'ClassAttribute',
     'path_type',
@@ -626,6 +627,46 @@ class ValueItems(Representation):
         return [(None, self._items)]
 
 
+def merge_include_exclude(
+    base: Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']],
+    override: Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']],
+    intersect: bool = False,
+) -> Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']]:
+    """
+    Merge include/exclude values from base and override.
+
+    This is a simplified wrapper around ValueItems.merge() used in various places
+    where we need to merge field include/exclude settings.
+
+    :param base: the base include/exclude value (e.g., from field config)
+    :param override: the override include/exclude value (e.g., from method call)
+    :param intersect: if True, merge with intersection; if False, merge with union
+    :return: the merged include/exclude value
+    """
+    override = ValueItems._coerce_value(override)
+    base = ValueItems._coerce_value(base)
+    if override is None:
+        return base
+    if ValueItems.is_true(base) or base is None:
+        return override
+    if ValueItems.is_true(override):
+        return base if intersect else override
+
+    # intersection or union of keys while preserving ordering:
+    if intersect:
+        merge_keys = [k for k in base if k in override] + [k for k in override if k in base]
+    else:
+        merge_keys = list(base) + [k for k in override if k not in base]
+
+    merged: 'DictIntStrAny' = {}
+    for k in merge_keys:
+        merged_item = ValueItems.merge(base.get(k), override.get(k), intersect=intersect)
+        if merged_item is not None:
+            merged[k] = merged_item
+
+    return merged
+
+
 class ClassAttribute:
     """
     Hide class attribute from its instances
